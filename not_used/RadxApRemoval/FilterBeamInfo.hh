// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
// ** Copyright UCAR (c) 1990 - 2016                                         
// ** University Corporation for Atmospheric Research (UCAR)                 
// ** National Center for Atmospheric Research (NCAR)                        
// ** Boulder, Colorado, USA                                                 
// ** BSD licence applies - redistribution and use in source and binary      
// ** forms, with or without modification, are permitted provided that       
// ** the following conditions are met:                                      
// ** 1) If the software is modified to produce derivative works,            
// ** such modified software should be clearly marked, so as not             
// ** to confuse it with the version available from UCAR.                    
// ** 2) Redistributions of source code must retain the above copyright      
// ** notice, this list of conditions and the following disclaimer.          
// ** 3) Redistributions in binary form must reproduce the above copyright   
// ** notice, this list of conditions and the following disclaimer in the    
// ** documentation and/or other materials provided with the distribution.   
// ** 4) Neither the name of UCAR nor the names of its contributors,         
// ** if any, may be used to endorse or promote products derived from        
// ** this software without specific prior written permission.               
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
/**
 *
 * @file FilterBeamInfo.hh
 *
 * @class FilterBeamInfo
 *
 * FilterBeamInfo is a class the manages the information for a beam in the
 * filtering process.
 *  
 * @date 8/4/2008
 *
 */

#ifndef FilterBeamInfo_HH
#define FilterBeamInfo_HH

using namespace std;

#include <dataport/port_types.h>


/** 
 * @class FilterBeamInfo
 */

class FilterBeamInfo
{

public:

  //////////////////
  // Public types //
  //////////////////

  /** 
   * @brief The types of interest fields generated by this code.
   *        N_INTEREST_FIELDS is included at the end so that we have a count
   *        of the interest types.  FINAL is the final interest calculated
   *        for this filter and FINALC is the final interest for this filter
   *        with the final confidence applied.
   */

  enum InterestType { TDBZ, GDZ, MVE, MSW, SDVE, SDSW, 
		      SC_SPIN, AP_SPIN, P_SPIN, SIGN, RGDZ, SRDZ, 
		      RSINZ, FINAL, FINALC,
		      N_INTEREST_FIELDS };


  ////////////////////
  // Public methods //
  ////////////////////

  /** 
   * @brief Constructor
   */

  FilterBeamInfo();

  /**
   * @brief Destructor
   */

  virtual ~FilterBeamInfo();
   

  /**
   * @brief Set up for the current beam.
   *
   * @param[in] azimuth Azimuth value for the current beam.
   * @param[in] num_gates Number of gates in this beam.
   */

  void setBeam(const double azimuth, const int num_gates);
  

  /**
   * @brief Get the azimuth for this beam.
   *
   * @return Returns the azimuth for this beam.
   */

  double getAzimuth() 
  {
    return _azimuth;
  }
  

  /**
   * @brief Calculate the interest value for the given gate.
   *
   * @param[in] int_type Interest field for which to calculate the interest.
   * @param[in] igate Gate index for the current gate in the current tilt.
   * @param[in] interest_val Interest value for this field.
   * @param[in] interest_weight Weight for the interest field.
   * @param[in] confidence_val Confidence value for this field.
   * @param[in] confidence_weight Weight for the confidence field.
   */

  void calcInterest(const InterestType int_type,
		    const int igate,
		    const double interest_val,
		    const double interest_weight,
		    const double confidence_val,
		    const double confidence_weight);
  

  /**
   * @brief Calculate the final interest value for the given gate.
   *
   * @param[in] igate Gate index for the current gate in the current tilt.
   * @param[in] apply_confidence Flag indicating whether a confidence function
   *                             was defined for the filter.
   */

  void calcFinal(const int igate, const bool apply_confidence);
  

  /**
   * @brief Set the final interest value for the given gate to the given
   *        value.
   *
   * @param[in] igate Gate index for the current gate in the current tilt.
   * @param[in] final_value The final interest value to use.
   */

  void setFinal(const int igate, const float final_value);
  

  /**
   * @brief Get the value for the given interest function at the given gate.
   *
   * @param[in] gate_num Gate index number.
   * @param[in] int_type Interest field identifier.
   *
   * @return Returns the specified interest value.
   */

  float getInterestValue(const int gate_num,
			 const InterestType int_type) const
  {
    return _interestPtrs[gate_num * N_INTEREST_FIELDS + int_type];
  }
  

  /**
   * @brief Scale the interest fields and return the data.
   *
   * @return Returns a pointer to the scaled interest data.  This pointer is
   *         owned by the calling method and should be deleted when no longer
   *         needed.
   */

  ui16 *getScaledInterest() const;
  

  /**
   * @brief Scale the confidence fields and return the data.
   *
   * @return Returns a pointer to the scaled confidence data.  This pointer is
   *         owned by the calling method and should be deleted when no longer
   *         needed.
   */

  ui16 *getScaledConfidence() const;
  

private:

  /////////////////////
  // Private members //
  /////////////////////

  /**
   * @brief Azimuth angle for this beam in degrees.
   */

  double _azimuth;
  
  /**
   * @brief The number of gates in the beam.
   */

  int _numGates;
  
  /**
   * @brief Ordered list of interest sums for each gate in this beam.
   *        There is one sum for each gate in the beam.  These sums are
   *        the sum of the interest associated with each feature field
   *        for the associated filter and are used to calculate the final
   *        interest field.
   */

  double *_interestSum;
  
  /**
   * @brief Ordered list of interest weight sums for each gate in this
   *        beam.  There is one weight sum for each gate in the beam.
   *        These sums are the sum of the interest function weights
   *        associated with each feature field for the associated filter
   *        and are used to calculate the final interest field.
   */

  double *_interestWeightSum;
  
  /**
   * @brief Ordered list of interest values for each gate in the beam.
   *        These are the interest values for each feature field for this
   *        filter.  There is one value for each field in each gate, with
   *        all of the interest field values for the first gate being
   *        followed by all of the interest field values for the second
   *        gate and so on.  The interest field values are in order defined
   *        by the InterestType enumeration.
   */

  float *_interestPtrs;
  
  /**
   * @brief Ordered list of confidence values for each gate in the beam.
   *        There is a value for each field in each gate, with all of the
   *        confidence field values for the first gate being followed by
   *        all of the confidence field values for the second gate and so
   *        on.  The confidence field values are in the order defined by the
   *        InterestType enumeration.
   */

  float *_confidencePtrs;
  
};

#endif
