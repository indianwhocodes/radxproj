/**********************************************************************
 * TDRP params for RadxCov2Mom
 **********************************************************************/

//======================================================================
//
// RadxCov2Mom reads covariances in Radx-supported format files, 
//   computes the moments and writes out the results to Radx-supported 
//   format files.
//
//======================================================================
 
//======================================================================
//
// DEBUGGING.
//
//======================================================================
 
///////////// debug ///////////////////////////////////
//
// Debug option.
// If set, debug messages will be printed appropriately.
//
// Type: enum
// Options:
//     DEBUG_OFF
//     DEBUG_NORM
//     DEBUG_VERBOSE
//     DEBUG_EXTRA
//

debug = DEBUG_NORM;

///////////// instance ////////////////////////////////
//
// Program instance for process registration.
// This application registers with procmap. This is the instance used 
//   for registration.
// Type: string
//

instance = "test";

//======================================================================
//
// THREADING FOR SPEED.
//
//======================================================================
 
///////////// use_multiple_threads ////////////////////
//
// Option to use multiple compute threads to improve performance.
// The read and write stages occur in the main thread, since netCDF is 
//   not thread safe. The compute stage can be multi-threaded to improve 
//   performance.
// Type: boolean
//

use_multiple_threads = TRUE;

///////////// n_compute_threads ///////////////////////
//
// The number of compute threads.
// The moments computations are segmented in range, with each thread 
//   computing a fraction of the number of gates. For maximum performance, 
//   n_threads should be set to the number of processors multiplied by 4. 
//   For further tuning, use top to maximize CPU usage while varying the 
//   number of threads.
// Minimum val: 1
// Type: int
//

n_compute_threads = 8;

//======================================================================
//
// DATA INPUT.
//
//======================================================================
 
///////////// input_dir ///////////////////////////////
//
// Input directory for searching for files.
// Files will be searched for in this directory.
// Type: string
//

input_dir = ".";

///////////// mode ////////////////////////////////////
//
// Operating mode.
// In REALTIME mode, the program waits for a new input file.  In ARCHIVE 
//   mode, it moves through the data between the start and end times set 
//   on the command line. In FILELIST mode, it moves through the list of 
//   file names specified on the command line. Paths (in ARCHIVE mode, at 
//   least) MUST contain a day-directory above the data file -- 
//   ./data_file.ext will not work as a file path, but 
//   ./yyyymmdd/data_file.ext will.
//
// Type: enum
// Options:
//     REALTIME
//     ARCHIVE
//     FILELIST
//

mode = FILELIST;

///////////// max_realtime_data_age_secs //////////////
//
// Maximum age of realtime data (secs).
// Only data less old than this will be used.
// Type: int
//

max_realtime_data_age_secs = 300;

//======================================================================
//
// READ OPTIONS.
//
//======================================================================
 
///////////// aggregate_sweep_files_on_read ///////////
//
// Option to aggregate sweep files into a volume on read.
// If true, and the input data is in sweeps rather than volumes (e.g. 
//   DORADE), the sweep files from a volume will be aggregated into a 
//   volume.
// Type: boolean
//

aggregate_sweep_files_on_read = FALSE;

///////////// ignore_idle_scan_mode_on_read ///////////
//
// Option to ignore data taken in IDLE mode.
// If true, on read will ignore files with an IDLE scan mode.
// Type: boolean
//

ignore_idle_scan_mode_on_read = TRUE;

///////////// remove_rays_with_all_data_missing ///////
//
// Option to remove rays for which all data is missing.
// If true, ray data will be checked. If all fields have missing data at 
//   all gates, the ray will be removed after reading.
// Type: boolean
//

remove_rays_with_all_data_missing = FALSE;

///////////// remove_rays_with_antenna_transitions ////
//
// Option to remove rays taken while the antenna was in transition.
// If true, rays with the transition flag set will not be used. The 
//   transiton flag is set when the antenna is in transtion between one 
//   sweep and the next.
// Type: boolean
//

remove_rays_with_antenna_transitions = TRUE;

///////////// transition_nrays_margin /////////////////
//
// Number of transition rays to include as a margin.
// Sometimes the transition flag is turned on too early in a transition, 
//   on not turned off quickly enough after a transition. If you set this 
//   to a number greater than 0, that number of rays will be included at 
//   each end of the transition, i.e. the transition will effectively be 
//   shorter at each end by this number of rays.
// Type: int
//

transition_nrays_margin = 2;

///////////// set_max_range ///////////////////////////
//
// Option to set the max range for any ray.
// Type: boolean
//

set_max_range = TRUE;

///////////// max_range_km ////////////////////////////
//
// Specified maximim range - km.
// Gates beyond this range are removed.
// Type: double
//

max_range_km = 147;

///////////// set_ngates_constant /////////////////////
//
// Option to force the number of gates to be constant.
// If TRUE, the number of gates on all rays will be set to the maximum, 
//   and gates added to shorter rays will be filled with missing values.
// Type: boolean
//

set_ngates_constant = FALSE;

///////////// set_fixed_angle_limits //////////////////
//
// Option to set fixed angle limits.
// Only use sweeps within the specified fixed angle limits.
// Type: boolean
//

set_fixed_angle_limits = FALSE;

///////////// lower_fixed_angle_limit /////////////////
//
// Lower fixed angle limit - degrees.
// Type: double
//

lower_fixed_angle_limit = 0;

///////////// upper_fixed_angle_limit /////////////////
//
// Upper fixed angle limit - degrees.
// Type: double
//

upper_fixed_angle_limit = 90;

///////////// set_sweep_num_limits ////////////////////
//
// Option to set sweep number limits.
// Only read sweeps within the specified sweep number limits.
// Type: boolean
//

set_sweep_num_limits = FALSE;

///////////// lower_sweep_num /////////////////////////
//
// Lower sweep number limit.
// Type: int
//

lower_sweep_num = 0;

///////////// upper_sweep_num /////////////////////////
//
// Upper sweep number limit.
// Type: int
//

upper_sweep_num = 0;

//======================================================================
//
// OPTION TO OVERRIDE RADAR LOCATION.
//
//======================================================================
 
///////////// override_radar_location /////////////////
//
// Option to override the radar location.
// If true, the location in this file will be used. If not, the location 
//   in the time series data will be used.
// Type: boolean
//

override_radar_location = FALSE;

///////////// radar_latitude_deg //////////////////////
//
// Radar latitude (deg).
// See override_radar_location.
// Type: double
//

radar_latitude_deg = -999;

///////////// radar_longitude_deg /////////////////////
//
// Radar longitude (deg).
// See override_radar_location.
// Type: double
//

radar_longitude_deg = -999;

///////////// radar_altitude_meters ///////////////////
//
// Radar altitude (meters).
// See override_radar_location.
// Type: double
//

radar_altitude_meters = -999;

//======================================================================
//
// INPUT COVARIANCE FIELDS.
//
// Finding the names of covariance fields in the input files.
//
//======================================================================
 
///////////// input_covars ////////////////////////////
//
// Indicate which field name is to be used for each covariance.
// Set the field name for each covariance type. If the covariance is not 
//   available in the input field, it will be set to missing.
//
// Type: struct
//   typedef struct {
//      covariance_id_t field_id;
//        Options:
//          LAG0_HC_DB
//          LAG0_HX_DB
//          LAG0_VC_DB
//          LAG0_VX_DB
//          LAG0_HCVX_DB
//          LAG0_HCVX_PHASE
//          LAG0_VCHX_DB
//          LAG0_VCHX_PHASE
//          LAG1_HC_DB
//          LAG1_HC_PHASE
//          LAG1_VC_DB
//          LAG1_VC_PHASE
//          LAG1_HCVC_DB
//          LAG1_HCVC_PHASE
//          LAG1_VCHC_DB
//          LAG1_VCHC_PHASE
//          LAG1_VXHX_DB
//          LAG1_VXHX_PHASE
//          LAG2_HC_DB
//          LAG2_HC_PHASE
//          LAG2_VC_DB
//          LAG2_VC_PHASE
//          LAG3_HC_DB
//          LAG3_HC_PHASE
//          LAG3_VC_DB
//          LAG3_VC_PHASE
//          RVVHH0_DB
//          RVVHH0_PHASE
//          CPA
//          CMD_FLAG
//      string field_name;
//   }
//
// 1D array - variable length.
//

input_covars = {
  {
    field_id = LAG0_HC_DB,
    field_name = "LAG0_HC_DB"
  }
  ,
  {
    field_id = LAG0_HX_DB,
    field_name = "LAG0_HX_DB"
  }
  ,
  {
    field_id = LAG0_VC_DB,
    field_name = "LAG0_VC_DB"
  }
  ,
  {
    field_id = LAG0_VX_DB,
    field_name = "LAG0_VX_DB"
  }
  ,
  {
    field_id = LAG0_HCVX_DB,
    field_name = "LAG0_HCVX_DB"
  }
  ,
  {
    field_id = LAG0_HCVX_PHASE,
    field_name = "LAG0_HCVX_PHASE"
  }
  ,
  {
    field_id = LAG0_VCHX_DB,
    field_name = "LAG0_VCHX_DB"
  }
  ,
  {
    field_id = LAG0_VCHX_PHASE,
    field_name = "LAG0_VCHX_PHASE"
  }
  ,
  {
    field_id = LAG1_HC_DB,
    field_name = "LAG1_HC_DB"
  }
  ,
  {
    field_id = LAG1_HC_PHASE,
    field_name = "LAG1_HC_PHASE"
  }
  ,
  {
    field_id = LAG1_VC_DB,
    field_name = "LAG1_VC_DB"
  }
  ,
  {
    field_id = LAG1_VC_PHASE,
    field_name = "LAG1_VC_PHASE"
  }
  ,
  {
    field_id = LAG1_HCVC_DB,
    field_name = "LAG1_HCVC_DB"
  }
  ,
  {
    field_id = LAG1_HCVC_PHASE,
    field_name = "LAG1_HCVC_PHASE"
  }
  ,
  {
    field_id = LAG1_VCHC_DB,
    field_name = "LAG1_VCHC_DB"
  }
  ,
  {
    field_id = LAG1_VCHC_PHASE,
    field_name = "LAG1_VCHC_PHASE"
  }
  ,
  {
    field_id = LAG1_VXHX_DB,
    field_name = "LAG1_VXHX_DB"
  }
  ,
  {
    field_id = LAG1_VXHX_PHASE,
    field_name = "LAG1_VXHX_PHASE"
  }
  ,
  {
    field_id = LAG2_HC_DB,
    field_name = "LAG2_HC_DB"
  }
  ,
  {
    field_id = LAG2_HC_PHASE,
    field_name = "LAG2_HC_PHASE"
  }
  ,
  {
    field_id = LAG2_VC_DB,
    field_name = "LAG2_VC_DB"
  }
  ,
  {
    field_id = LAG2_VC_PHASE,
    field_name = "LAG2_VC_PHASE"
  }
  ,
  {
    field_id = LAG3_HC_DB,
    field_name = "LAG3_HC_DB"
  }
  ,
  {
    field_id = LAG3_HC_PHASE,
    field_name = "LAG3_HC_PHASE"
  }
  ,
  {
    field_id = LAG3_VC_DB,
    field_name = "LAG3_VC_DB"
  }
  ,
  {
    field_id = LAG3_VC_PHASE,
    field_name = "LAG3_VC_PHASE"
  }
  ,
  {
    field_id = RVVHH0_DB,
    field_name = "RVVHH0_DB"
  }
  ,
  {
    field_id = RVVHH0_PHASE,
    field_name = "RVVHH0_PHASE"
  }
  ,
  {
    field_id = CPA,
    field_name = "CPA"
  }
  ,
  {
    field_id = CMD_FLAG,
    field_name = "CMD_FLAG"
  }
};

//======================================================================
//
// NOISE DETECTION.
//
//======================================================================
 
///////////// ngates_for_noise_detection //////////////
//
// Number of gates over which the noise detection feature fields are 
//   computed.
// To identify noise at a gate, we accumulate the phase change in range 
//   for the entire ray. We then assume that the phase change will be 
//   linear in a local sense, i.e. within some region around each gate. 
//   This parameter specifies the length of the assumed linear region. The 
//   phase change error is computed as the mean absolute error between the 
//   actual accumulated phase change and the linear fit to the phase 
//   change over the local region. NOTE - this number should be odd.
// Type: int
//

ngates_for_noise_detection = 9;

///////////// min_ngates_for_mean_noise ///////////////
//
// Min number of gates for computing noise.
// In order to compute noise for a ray, we require noise to be detected 
//   at at least this number of gates.
// Type: int
//

min_ngates_for_mean_noise = 100;

///////////// noise_method ////////////////////////////
//
// Method for computing mean noise.
// 	RAY_BY_RAY: compute noise for each ray individually. 
//   	RUNNING_MEDIAN: store noise values in an array, and compute the mean 
//   noise when we have enough data. The noise varies more smoothly than 
//   in the RAY_BY_RAY method.
//
// Type: enum
// Options:
//     NOISE_RAY_BY_RAY
//     NOISE_RUNNING_MEDIAN
//

noise_method = NOISE_RAY_BY_RAY;

///////////// ngates_for_running_median_noise /////////
//
// Number of gates used to compute noise running mean.
// When noise is located at a gate, the power values are stored in 
//   arrays. When we have accumulated enough gates, the mean is computed.
// Type: int
//

ngates_for_running_median_noise = 2500;

//======================================================================
//
// INTEREST MAPS and WEIGHTS for NOISE LOCATION.
//
// Each map should hold at least 2 points. The points should be 
//   increasing in value, i.e. the value should increase for each 
//   subsequent point. The various interest values are combined using the 
//   specified weights in a weighted mean to produce the final interest 
//   value.
//
//======================================================================
 
///////////// phase_change_error_for_noise_interest_map 
//
// Interest mapping for phase change for noise.
//
// Type: struct
//   typedef struct {
//      double value;
//      double interest;
//   }
//
// 1D array - variable length.
//

phase_change_error_for_noise_interest_map = {
  {
    value = 40,
    interest = 0.001
  }
  ,
  {
    value = 50,
    interest = 1
  }
};

///////////// phase_change_error_for_noise_interest_weight 
//
// Weight for interest for phase change error - for noise.
// The relative weighting applied when computing the fuzzy sum.
// Type: double
//

phase_change_error_for_noise_interest_weight = 1;

///////////// dbm_sdev_for_noise_interest_map /////////
//
// Interest mapping for sdev of dbm for noise.
//
// Type: struct
//   typedef struct {
//      double value;
//      double interest;
//   }
//
// 1D array - variable length.
//

dbm_sdev_for_noise_interest_map = {
  {
    value = 0.65,
    interest = 1
  }
  ,
  {
    value = 0.75,
    interest = 0.001
  }
};

///////////// dbm_sdev_for_noise_interest_weight //////
//
// Weight for interest for sdev of dbm - for noise.
// The relative weighting applied when computing the fuzzy sum.
// Type: double
//

dbm_sdev_for_noise_interest_weight = 1;

///////////// ncp_mean_for_noise_interest_map /////////
//
// Interest mapping for mean of ncp for noise.
//
// Type: struct
//   typedef struct {
//      double value;
//      double interest;
//   }
//
// 1D array - variable length.
//

ncp_mean_for_noise_interest_map = {
  {
    value = 0.1,
    interest = 1
  }
  ,
  {
    value = 0.15,
    interest = 0.001
  }
};

///////////// ncp_mean_for_noise_interest_weight //////
//
// Weight for interest for sdev of dbm - for noise.
// The relative weighting applied when computing the fuzzy sum.
// Type: double
//

ncp_mean_for_noise_interest_weight = 1;

///////////// interest_threshold_for_noise ////////////
//
// Threshold interest value for identifying noise.
// If the fuzzy interest value exceeds this threshold, noise is assumed 
//   to exist at that gate.
// Type: double
//

interest_threshold_for_noise = 0.65;

///////////// phase_change_error_for_signal_interest_map 
//
// Interest mapping for phase change for signal.
//
// Type: struct
//   typedef struct {
//      double value;
//      double interest;
//   }
//
// 1D array - variable length.
//

phase_change_error_for_signal_interest_map = {
  {
    value = 10,
    interest = 0.001
  }
  ,
  {
    value = 20,
    interest = 1
  }
};

///////////// phase_change_error_for_signal_interest_weight 
//
// Weight for interest for phase change error - for signal.
// The relative weighting applied when computing the fuzzy sum.
// Type: double
//

phase_change_error_for_signal_interest_weight = 1;

///////////// dbm_sdev_for_signal_interest_map ////////
//
// Interest mapping for sdev of dbm for signal.
//
// Type: struct
//   typedef struct {
//      double value;
//      double interest;
//   }
//
// 1D array - variable length.
//

dbm_sdev_for_signal_interest_map = {
  {
    value = 0.75,
    interest = 1
  }
  ,
  {
    value = 0.85,
    interest = 0.001
  }
};

///////////// dbm_sdev_for_signal_interest_weight /////
//
// Weight for interest for sdev of dbm - for signal.
// The relative weighting applied when computing the fuzzy sum.
// Type: double
//

dbm_sdev_for_signal_interest_weight = 1;

///////////// interest_threshold_for_signal ///////////
//
// Threshold interest value for identifying signal.
// If the fuzzy interest value exceeds this threshold, signal is assumed 
//   to exist at that gate.
// Type: double
//

interest_threshold_for_signal = 0.51;

//======================================================================
//
// MOMENTS COMPUTATIONS.
//
//======================================================================
 
///////////// xmit_rcv_mode ///////////////////////////
//
// Transmit/receive mode.
// This governs the type of moments computations to be applied.
// 	SINGLE_POL:
// 		Single polarization
// 	DUAL_POL_ALT_HV_CO_ONLY:
// 		Dual pol, alternating transmission
// 		          copolar receiver only
// 	DUAL_POL_ALT_HV_CO_CROSS:
// 		Dual pol, alternating transmission
// 		          co-polar and cross-polar receivers
// 	DUAL_POL_SIM_HV:
// 		Dual pol, simultaneous transmit/receive
// 	DUAL_POL_H_ONLY:
// 		Dual pol, H transmission
// 		          simultaneous H and V receive
// 	DUAL_POL_V_ONLY:
// 		Dual pol, V transmission
// 		          simultaneous H and V receive.
//
// Type: enum
// Options:
//     SINGLE_POL
//     DUAL_POL_ALT_HV_CO_ONLY
//     DUAL_POL_ALT_HV_CO_CROSS
//     DUAL_POL_SIM_HV
//     DUAL_POL_H_ONLY
//     DUAL_POL_V_ONLY
//

xmit_rcv_mode = DUAL_POL_ALT_HV_CO_CROSS;

///////////// is_filtered /////////////////////////////
//
// Are these filtered covariances?.
// Type: boolean
//

is_filtered = TRUE;

///////////// use_estimated_noise_for_noise_subtraction 
//
// Option to correct power for estimated noise.
// We estimate the noise by identifying regions with noise and computing 
//   the mean power - see above. If this parameter is set to TRUE, we use 
//   the estimated noise instead of teh calibrated noise to compute the 
//   noise-subtracted powers.
// Type: boolean
//

use_estimated_noise_for_noise_subtraction = TRUE;

///////////// correct_for_system_phidp ////////////////
//
// Option to correct for system phidp.
// If true, the H and V correlation phases will be corrected by 
//   adding/subtracting the system phidp value as appropriate. This avoids 
//   premature wrapping of the phased from which phidp and velocity are 
//   computed. If false, this correction will not be applied. To find the 
//   system phidp, set this to false and compute phidp for 
//   vertically-pointing data.
// Type: boolean
//

correct_for_system_phidp = TRUE;

///////////// change_velocity_sign ////////////////////
//
// Option to change sign on velocity field.
// Set to true to change the sign of the computed radial velocity field.
// Type: boolean
//

change_velocity_sign = FALSE;

///////////// use_hybrid_for_width ////////////////////
//
// Option to use the hybrid estimator for spectrum width, if applicable.
// In some modes, we can compute the spectrum width with the NCAR hybrid 
//   spectrum width estimator. If this is set, the hybrid width will be 
//   used for all modes except dual pol alternating mode.
// Type: boolean
//

use_hybrid_for_width = TRUE;

///////////// min_snr_db_for_zdr //////////////////////
//
// Min SNR for computing ZDR (dB).
// If the SNR is below this threshold, ZDR will be set to missing.
// Type: double
//

min_snr_db_for_zdr = -30;

///////////// min_snr_db_for_ldr //////////////////////
//
// Min SNR for computing LDR (dB).
// If the SNR is below this threshold, LDR will be set to missing.
// Type: double
//

min_snr_db_for_ldr = -30;

///////////// adjust_dbz_for_measured_xmit_power //////
//
// Option to adjust DBZ based on measured transmitter power.
// If true, and the measured transmitter power is available, the 
//   difference between the measured power and calibration power will be 
//   used to adjust the computed DBZ fields.
// Type: boolean
//

adjust_dbz_for_measured_xmit_power = FALSE;

///////////// adjust_zdr_for_measured_xmit_power //////
//
// Option to adjust ZDR based on measured transmitter power.
// If true, and the measured transmitter power is available, the 
//   difference between the measured power and calibration power will be 
//   used to adjust the computed ZDR fields.
// Type: boolean
//

adjust_zdr_for_measured_xmit_power = FALSE;

//======================================================================
//
// ATMOSPHERIC ATTENUATION CORRECTION METHOD.
//
//======================================================================
 
///////////// atmos_atten_method //////////////////////
//
// Method for computing atmospheric attenuation.
// This is applied to the DBZ fields only.
// 	ATMOS_ATTEN_NONE:
// 		No correction is applied
// 	ATMOS_ATTEN_CONSTANT:
// 		A constant correction in dB/km is applied
// 		See atmos_atten_db_per_km
// 	ATMOS_ATTEN_CRPL:
// 		Uses the method based on the Central Radio Propagation Laboratory
// 		measurements.
// 		See Doviak and Zrnic, page 44.
//
// Type: enum
// Options:
//     ATMOS_ATTEN_NONE
//     ATMOS_ATTEN_CONSTANT
//     ATMOS_ATTEN_CRPL
//

atmos_atten_method = ATMOS_ATTEN_CRPL;

///////////// atmos_atten_db_per_km ///////////////////
//
// Constant atmospheric attenuation (dB/km).
// DBZ is corrected for this.
// Type: double
//

atmos_atten_db_per_km = 0.012;

//======================================================================
//
// RADAR CALIBRATION XML FILES.
//
//======================================================================
 
///////////// cal_files ///////////////////////////////
//
// Specify the calibration file for each pulse width.
// First, the program will determine which of the specified pulse widths 
//   best matches the pulse width in the data. The closest match will be 
//   used to determine the cal file.

// NOTE - the pulse width is specified in micro-seconds.
//
// Type: struct
//   typedef struct {
//      double pulse_width_us;
//      string cal_file_path;
//   }
//
// 1D array - variable length.
//

cal_files = {
  {
    pulse_width_us = 1,
    cal_file_path = "$(PROJ_DIR)/mgen/params/sband_cal.xml"
  }
};

//======================================================================
//
// COMPUTING KDP.
//
// Parameters for computing KDP.
//
//======================================================================
 
///////////// KDP_fir_filter_len //////////////////////
//
// Filter length for the FIR filter for PHIDP (gates).
// When computing KDP, an FIR filter is first applied to PHIDP to smooth 
//   it. This is the length of that filter, in gates.
//
// Type: enum
// Options:
//     FIR_LEN_125
//     FIR_LEN_30
//     FIR_LEN_20
//     FIR_LEN_10
//

KDP_fir_filter_len = FIR_LEN_20;

///////////// KDP_phidp_difference_threshold //////////
//
// Sets the threshold for difference of phidp.
// This is used to test the difference between the unfolded phidp value 
//   and the filtered phidp value. If the difference exceeds this value, 
//   we use the original value instead of the filtered value. Applies to 
//   computation of KDP only.
// Type: double
//

KDP_phidp_difference_threshold = 4;

///////////// KDP_phidp_sdev_threshold ////////////////
//
// Sets the threshold for the standard deviation of phidp in range.
// The sdev of phidp is a good test for weather. If the sdev is less 
//   than this value, it is assumed we are in weather. Applies to 
//   computation of KDP only.
// Type: double
//

KDP_phidp_sdev_threshold = 12;

///////////// KDP_zdr_sdev_threshold //////////////////
//
// Sets the threshold for the standard deviation of zdr in range.
// The sdev of zdr is a good test for weather. If the sdev is less than 
//   this value, it is assumed we are in weather. Applies to computation 
//   of KDP only.
// Type: double
//

KDP_zdr_sdev_threshold = 1.8;

///////////// KDP_rhohv_threshold /////////////////////
//
// Sets the threshold for rhohv.
// rhohv is a good test for weather. If rhohv is greater than this 
//   value, it is assumed we are in weather. Applies to computation of KDP 
//   only.
// Type: double
//

KDP_rhohv_threshold = 0.75;

///////////// KDP_constrain_using_dbz /////////////////
//
// Option to constrain KDP to reasonable values using dbz.
// If true, the KDP values will be checked against DBZ, and will be 
//   limited to a reasonable range given the DBZ value.
// Type: boolean
//

KDP_constrain_using_dbz = FALSE;

///////////// KDP_apply_median_filter_to_PHIDP ////////
//
// Option to filter PHIDP with median filter.
// The filter is applied in range.
// Type: boolean
//

KDP_apply_median_filter_to_PHIDP = TRUE;

///////////// KDP_median_filter_len_for_PHIDP /////////
//
// Length of median filter for PHIDP - gates.
// See 'apply_median_filter_to_PHIDP'.
// Type: int
//

KDP_median_filter_len_for_PHIDP = 5;

//======================================================================
//
// COMPUTING PID - HYDROMETEOR PARTICLE ID.
//
//======================================================================
 
///////////// compute_pid /////////////////////////////
//
// Option to compute the particle ID product - PID.
// Only applies to dual-polarization data.
// Type: boolean
//

compute_pid = TRUE;

///////////// pid_thresholds_file_path ////////////////
//
// File path for fuzzy logic thresholds for PID.
// This file contains the thresholds and weights for computing particle 
//   ID.
// Type: string
//

pid_thresholds_file_path = "$(PROJ_DIR)/alg/params/pid_thresholds.sband";

///////////// PID_snr_threshold ///////////////////////
//
// Minimum SNR for valid PID.
// If the SNR at a gate is below this, the PID is censored.
// Type: double
//

PID_snr_threshold = 3;

///////////// PID_min_valid_interest //////////////////
//
// Minimum valid interest value for identifying a particle.
// If the computed interest value is below this, the PID is set to 
//   missing.
// Type: double
//

PID_min_valid_interest = 0.5;

///////////// PID_constrain_kdp_using_dbz /////////////
//
// For PID, constrain KDP to reasonable values using dbz.
// If true, the KDP values will be checked against DBZ, and will be 
//   limited to a reasonable range given the DBZ value.
// Type: boolean
//

PID_constrain_kdp_using_dbz = FALSE;

///////////// PID_apply_median_filter_to_DBZ //////////
//
// Option to filter DBZ with median filter.
// The filter is computed in range.
// Type: boolean
//

PID_apply_median_filter_to_DBZ = TRUE;

///////////// PID_DBZ_median_filter_len ///////////////
//
// Length of median filter for DBZ - gates.
// See 'PID_apply_median_filter_to_DBZ'.
// Type: int
//

PID_DBZ_median_filter_len = 5;

///////////// PID_apply_median_filter_to_ZDR //////////
//
// Option to filter ZDR with median filter.
// The filter is computed in range.
// Type: boolean
//

PID_apply_median_filter_to_ZDR = TRUE;

///////////// PID_ZDR_median_filter_len ///////////////
//
// Length of median filter for ZDR - gates.
// See 'PID_apply_median_filter_to_ZDR'.
// Type: int
//

PID_ZDR_median_filter_len = 5;

///////////// PID_apply_median_filter_to_RHOHV ////////
//
// Option to filter RHOHV with median filter.
// The filter is computed in range.
// Type: boolean
//

PID_apply_median_filter_to_RHOHV = TRUE;

///////////// PID_RHOHV_median_filter_len /////////////
//
// Length of median filter for RHOHV - gates.
// See 'PID_apply_median_filter_to_RHOHV'.
// Type: int
//

PID_RHOHV_median_filter_len = 5;

///////////// PID_apply_median_filter_to_LDR //////////
//
// Option to filter LDR with median filter.
// The filter is computed in range.
// Type: boolean
//

PID_apply_median_filter_to_LDR = TRUE;

///////////// PID_LDR_median_filter_len ///////////////
//
// Length of median filter for LDR - gates.
// See 'PID_apply_median_filter_to_LDR'.
// Type: int
//

PID_LDR_median_filter_len = 5;

///////////// PID_replace_missing_LDR /////////////////
//
// For PID, option to replace missing LDR values with a specified value.
// When the SNR gets low, LDR is unreliable since there is not 
//   sufficient dynamic range to provide an accurate cross-polar power 
//   measurement. In these cases, it makes sense to replace LDR with a 
//   neutral value, such as 0.0, so that we do not reject gates at which 
//   valuable data is available.
// Type: boolean
//

PID_replace_missing_LDR = TRUE;

///////////// PID_LDR_replacement_value ///////////////
//
// Value to which LDR will be set if missing.
// Type: double
//

PID_LDR_replacement_value = 0;

///////////// PID_ngates_for_sdev /////////////////////
//
// Number of gates for computing standard deviations.
// This applies to computing the standard deviation of zdr and phidp.
// Type: int
//

PID_ngates_for_sdev = 9;

//======================================================================
//
// SOUNDING INPUT FOR PID temperatures - OPTIONAL.
//
//======================================================================
 
///////////// use_soundings_from_spdb /////////////////
//
// Option to read sounding data from SPDB.
// If TRUE, the program will read the closest (in time) available 
//   sounding from an SPDB data base. The temperature profile from the 
//   sounding will be used to override the temperature profile in the PID 
//   thresholds config file.
// Type: boolean
//

use_soundings_from_spdb = TRUE;

///////////// sounding_spdb_url ///////////////////////
//
// SPDB URL for sounding data.
// Type: string
//

sounding_spdb_url = "spdbp:://tesla.eol.ucar.edu::spdb/soundings/gan";

///////////// sounding_search_time_margin_secs ////////
//
// Time margin for retrieving sounding, in secs.
// This is the total size of the output FMQ buffer. Some of this buffer 
//   will be used for control bytes (12 bytes per message).
// Type: int
//

sounding_search_time_margin_secs = 86400;

///////////// sounding_required_pressure_range_hpa ////
//
// Required pressure range for sounding to be valid (hPa).
// This is used to provide a quality check on the sounding. If the 
//   pressure data does not fully cover this range, the sounding is 
//   rejected and we look back for the next available one.
//
// Type: struct
//   typedef struct {
//      double min_val;
//      double max_val;
//   }
//
//

sounding_required_pressure_range_hpa = {
    min_val = 300,
    max_val = 950
};

///////////// sounding_required_height_range_m ////////
//
// Required height range for sounding to be valid (m).
// This is used to provide a quality check on the sounding. If the 
//   height data does not fully cover this range, the sounding is rejected 
//   and we look back for the next available one.
//
// Type: struct
//   typedef struct {
//      double min_val;
//      double max_val;
//   }
//
//

sounding_required_height_range_m = {
    min_val = 500,
    max_val = 15000
};

///////////// sounding_check_pressure_monotonically_decreasing 
//
// Option to check that pressure decreases monotonically.
// If TRUE, we will check that pressure decreases monotonically. If not, 
//   the sounding is rejected and we look back for the next available one.
// Type: boolean
//

sounding_check_pressure_monotonically_decreasing = TRUE;

//======================================================================
//
// SMOOTHING OUTPUT PID.
//
// This section gives you the option of smoothing the output pid field 
//   in range by applying a median filter.
//
//======================================================================
 
///////////// apply_median_filter_to_PID //////////////
//
// Option to filter PID with median filter.
// The filter is computed in range, and affects both rain rate and PID.
// Type: boolean
//

apply_median_filter_to_PID = FALSE;

///////////// PID_median_filter_len ///////////////////
//
// Length of median filter for PID - gates.
// See 'appply_median_filter_to_PID'.
// Type: int
//

PID_median_filter_len = 7;

//======================================================================
//
// COMPUTING PRECIP RATE.
//
//======================================================================
 
///////////// compute_precip_rate /////////////////////
//
// Option to estimate the precip rate.
// Only applies to dual-polarization data. A number of different 
//   estimates are computed, from ZH, Z-ZDR, KDP, KDP-ZDR and a hybrid of 
//   all of the above.
// Type: boolean
//

compute_precip_rate = TRUE;

///////////// PRECIP_snr_threshold ////////////////////
//
// Minimum SNR for valid PRECIP.
// If the SNR at a gate is below this, the PRECIP is censored.
// Type: double
//

PRECIP_snr_threshold = 3;

///////////// PRECIP_apply_median_filter_to_DBZ ///////
//
// Option to filter DBZ with median filter.
// The filter is computed in rang..
// Type: boolean
//

PRECIP_apply_median_filter_to_DBZ = TRUE;

///////////// PRECIP_DBZ_median_filter_len ////////////
//
// Length of median filter for DBZ - gates.
// See 'PRECIP_apply_median_filter_to_DBZ'.
// Type: int
//

PRECIP_DBZ_median_filter_len = 5;

///////////// PRECIP_apply_median_filter_to_ZDR ///////
//
// Option to filter ZDR with median filter.
// The filter is computed in range.
// Type: boolean
//

PRECIP_apply_median_filter_to_ZDR = TRUE;

///////////// PRECIP_ZDR_median_filter_len ////////////
//
// Length of median filter for ZDR - gates.
// See 'PID_PRECIP_apply_median_filter_to_ZDR'.
// Type: int
//

PRECIP_ZDR_median_filter_len = 5;

///////////// PRECIP_min_DBZ_for_KDP_rates ////////////
//
// KDP-based rates will be set to 0 for gates with DBZ values below this 
//   threshold.
// KDP can be a noisy field, which can lead to large KDP-based estimates 
//   even in low reflectivity areas. Use of this threshold prevents high 
//   KDP estimates in low reflectivity regions.
// Type: double
//

PRECIP_min_DBZ_for_KDP_rates = 30;

///////////// PRECIP_constrain_kdp_using_dbz //////////
//
// For precip, constrain KDP to reasonable values using dbz.
// If true, the KDP values will be checked against DBZ, and will be 
//   limited to a reasonable range given the DBZ value.
// Type: boolean
//

PRECIP_constrain_kdp_using_dbz = FALSE;

///////////// PRECIP_constrain_zdr_using_dbz //////////
//
// For precip, constrain ZDR to reasonable values using dbz.
// If true, the ZDR values will be checked against DBZ, and will be 
//   limited to a reasonable range given the DBZ value.
// Type: boolean
//

PRECIP_constrain_zdr_using_dbz = FALSE;

///////////// PRECIP_min_valid_rate ///////////////////
//
// Minimum valid precip rate (mm/hr).
// If any computed rate is less than this value, it is set to 0.
// Type: double
//

PRECIP_min_valid_rate = 0.1;

//======================================================================
//
// PRECIP COEFFICIENTS.
//
// Coefficients for the precip equations.
//
//======================================================================
 
//======================================================================
//
// PRECIP_RATE_ZH.
//
// RATE_ZH = zh_aa * (ZH ** zh_bb).
//
//======================================================================
 
///////////// zh_aa ///////////////////////////////////
//
// Coefficient for PRECIP_RATE_ZH.
// Type: double
//

zh_aa = 0.027366;

///////////// zh_bb ///////////////////////////////////
//
// Exponent for PRECIP_RATE_ZH.
// Type: double
//

zh_bb = 0.69444;

//======================================================================
//
// PRECIP_RATE_Z_ZDR.
//
// RATE_Z_ZDR = zzdr_aa * (ZH ** zzdr_bb) * (ZDR ** zzdr_cc).
//
//======================================================================
 
///////////// zzdr_aa /////////////////////////////////
//
// Coefficient for PRECIP_RATE_ZZDR.
// Type: double
//

zzdr_aa = 0.00684;

///////////// zzdr_bb /////////////////////////////////
//
// ZH exponent for PRECIP_RATE_ZZDR.
// Type: double
//

zzdr_bb = 1;

///////////// zzdr_cc /////////////////////////////////
//
// ZDR exponent for PRECIP_RATE_ZZDR.
// Type: double
//

zzdr_cc = -4.86;

//======================================================================
//
// PRECIP_RATE_KDP.
//
// RATE_KDP = sign(KDP) * kdp_aa * (|KDP| ** kdp_bb).
//
//======================================================================
 
///////////// kdp_aa //////////////////////////////////
//
// Coefficient for PRECIP_RATE_KDP.
// Type: double
//

kdp_aa = 40.6;

///////////// kdp_bb //////////////////////////////////
//
// Exponent for PRECIP_RATE_KDP.
// Type: double
//

kdp_bb = 0.866;

//======================================================================
//
// PRECIP_RATE_KDP_ZDR.
//
// RATE_KDP_ZDR = sign(KDP) * kdpzdr_aa * (|KDP| ** kdpzdr_bb) * (ZDR ** 
//   kdpzdr_cc).
//
//======================================================================
 
///////////// kdpzdr_aa ///////////////////////////////
//
// Coefficient for PRECIP_RATE_KDP_ZDR.
// Type: double
//

kdpzdr_aa = 136;

///////////// kdpzdr_bb ///////////////////////////////
//
// KDP exponent for PRECIP_RATE_KDP_ZDR.
// Type: double
//

kdpzdr_bb = 0.968;

///////////// kdpzdr_cc ///////////////////////////////
//
// ZDR exponent for PRECIP_RATE_KDP_ZDR.
// Type: double
//

kdpzdr_cc = -2.86;

//======================================================================
//
// PRECIP_RATE_HYBRID.
//
// The HYBRID rate is a combination of the other rates.
//
//======================================================================
 
///////////// hybrid_aa ///////////////////////////////
//
// If RATE_ZH <= hybrid_aa, RATE_HYBRID = RATE_ZH.
// Type: double
//

hybrid_aa = 10;

///////////// hybrid_bb ///////////////////////////////
//
// Else if RATE_Z_ZDR <= hybrid_bb, RATE_HYBRID = RATE_Z_ZDR.
// Type: double
//

hybrid_bb = 50;

///////////// hybrid_cc ///////////////////////////////
//
// Else If RATE_Z_ZDR <= hybrid_cc, RATE_HYBRID = RATE_KDP_ZDR.
// Else if RATE_Z_ZDR > hybrid_bb, RATE_HYBRID = RATE_KDP.
// Type: double
//

hybrid_cc = 100;

//======================================================================
//
// LOADING UP TEST FIELDS - for debugging.
//
//======================================================================
 
///////////// load_alt_vel2_test_fields ///////////////
//
// Option to load up test fields when computing alternative vel2 for 
//   alternating mode.
// If true, the following will be loaded:
// 	test2: meanConfidence for gap run.
// 	test3: min velocity for a gap run.
// 	test4: max velocity for a gap run.
// 	test5: corrected velocity for run with incorrect unfold.
// Type: boolean
//

load_alt_vel2_test_fields = FALSE;

//======================================================================
//
// SPECIFYING FIELD NAMES AND OUTPUT ENCODING.
//
//======================================================================
 
///////////// output_fields ///////////////////////////
//
// Indicate which fields should be written to the output file.
// Choose the ID from the list. The name and units can be set however 
//   the user prefers. The ECHO fields are provided to check that the 
//   output matches the input.

// The output_encoding and output_scaling apply to CfRadial output only. 
//   If the output_scaling is DYNAMIC then the scale and offset are 
//   computed using the dynamic range of the data. If the output_scaling 
//   is SPECIFIED, then the specified scale and offset are used.
//
// Type: struct
//   typedef struct {
//      output_field_id_t id;
//        Options:
//          NCP
//          SNR
//          DBM
//          DBZ
//          DBZHC
//          DBZVC
//          DBZHX
//          DBZVX
//          DBZ_NO_ATMOS_ATTEN
//          VEL
//          VEL2
//          VEL_HV
//          VEL2_FOLD_INTERVAL
//          VEL2_FOLD_CONFIDENCE
//          VEL_DIFF
//          VEL_UNFOLD_INTERVAL
//          WIDTH
//          ZDRM
//          ZDR
//          LDRHM
//          LDRH
//          LDRVM
//          LDRV
//          RHOHV
//          PHIDP0
//          PHIDP
//          PHIDP_COND
//          PHIDP_FILT
//          KDP
//          PSOB
//          SNRHC
//          SNRHX
//          SNRVC
//          SNRVX
//          DBMHC
//          DBMHX
//          DBMVC
//          DBMVX
//          PHASE_FOR_NOISE
//          ACCUM_PHASE_CHANGE
//          PHASE_CHANGE_ERROR
//          DBM_SDEV
//          NCP_MEAN
//          NOISE_FLAG
//          SIGNAL_FLAG
//          NOISE_BIAS_DB_HC
//          NOISE_BIAS_DB_HX
//          NOISE_BIAS_DB_VC
//          NOISE_BIAS_DB_VX
//          ECHO_LAG0_HC_DB
//          ECHO_LAG0_HX_DB
//          ECHO_LAG0_VC_DB
//          ECHO_LAG0_VX_DB
//          ECHO_LAG0_HCVX_DB
//          ECHO_LAG0_HCVX_PHASE
//          ECHO_LAG0_VCHX_DB
//          ECHO_LAG0_VCHX_PHASE
//          ECHO_LAG1_HC_DB
//          ECHO_LAG1_HC_PHASE
//          ECHO_LAG1_VC_DB
//          ECHO_LAG1_VC_PHASE
//          ECHO_LAG1_HCVC_DB
//          ECHO_LAG1_HCVC_PHASE
//          ECHO_LAG1_VCHC_DB
//          ECHO_LAG1_VCHC_PHASE
//          ECHO_LAG1_VXHX_DB
//          ECHO_LAG1_VXHX_PHASE
//          ECHO_LAG2_HC_DB
//          ECHO_LAG2_HC_PHASE
//          ECHO_LAG2_VC_DB
//          ECHO_LAG2_VC_PHASE
//          ECHO_LAG3_HC_DB
//          ECHO_LAG3_HC_PHASE
//          ECHO_LAG3_VC_DB
//          ECHO_LAG3_VC_PHASE
//          ECHO_RVVHH0_DB
//          ECHO_RVVHH0_PHASE
//          ECHO_CPA
//          ECHO_CMD_FLAG
//          TEST
//          TEST2
//          TEST3
//          TEST4
//          TEST5
//          PRECIP_RATE_ZH
//          PRECIP_RATE_Z_ZDR
//          PRECIP_RATE_KDP
//          PRECIP_RATE_KDP_ZDR
//          PRECIP_RATE_HYBRID
//          DBZ_FOR_KDP
//          ZDR_FOR_KDP
//          RHOHV_FOR_KDP
//          SNR_FOR_KDP
//          PHIDP_FOR_KDP
//          PHIDP_FILT_FOR_KDP
//          SDPHIDP_FOR_KDP
//          SDZDR_FOR_KDP
//          DBZ_FOR_RATE
//          ZDR_FOR_RATE
//          KDP_FOR_RATE
//          PARTICLE_ID
//          PID_INTEREST
//          DBZ_FOR_PID
//          ZDR_FOR_PID
//          LDR_FOR_PID
//          PHIDP_FOR_PID
//          RHOHV_FOR_PID
//          KDP_FOR_PID
//          SDZDR_FOR_PID
//          SDPHIDP_FOR_PID
//          TEMP_FOR_PID
//      string name;
//      string long_name;
//      string standard_name;
//      string units;
//      output_encoding_t encoding;
//        Options:
//          OUTPUT_ENCODING_FL32
//          OUTPUT_ENCODING_INT32
//          OUTPUT_ENCODING_INT16
//          OUTPUT_ENCODING_INT08
//      output_scaling_t scaling;
//        Options:
//          OUTPUT_SCALING_DYNAMIC
//          OUTPUT_SCALING_SPECIFIED
//      double scale;
//      double offset;
//   }
//
// 1D array - variable length.
//

output_fields = {
  {
    id = DBZ,
    name = "DBZ_F",
    long_name = "radar_reflectivity",
    standard_name = "equivalent_reflectivity_factor",
    units = "dBZ",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = DBZ_NO_ATMOS_ATTEN,
    name = "DBZ_NO_ATMOS_ATTEN_F",
    long_name = "DBZ_with_no_atmospheric_attenuation_correction",
    standard_name = "equivalent_reflectivity_factor",
    units = "dBZ",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = VEL,
    name = "VEL_F",
    long_name = "radial_velocity",
    standard_name = "radial_velocity_away_from_instrument",
    units = "m/s",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = VEL2,
    name = "VEL2_F",
    long_name = "radial_velocity_2",
    standard_name = "radial_velocity_away_from_instrument",
    units = "m/s",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = VEL_HV,
    name = "VEL_HV_F",
    long_name = "radial_velocity_hv_separately",
    standard_name = "radial_velocity_away_from_instrument",
    units = "m/s",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = WIDTH,
    name = "WIDTH_F",
    long_name = "doppler_spectrum_width",
    standard_name = "doppler_spectrum_width",
    units = "m/s",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = ZDRM,
    name = "ZDRM_F",
    long_name = "measured_log_differential_reflectivity",
    standard_name = "measured_log_differential_reflectivity",
    units = "dB",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = ZDR,
    name = "ZDR_F",
    long_name = "calibrated_log_differential_reflectivity",
    standard_name = "log_differential_reflectivity",
    units = "dB",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = LDRH,
    name = "LDRH_F",
    long_name = "linear_depolarization_ratio_h_channel",
    standard_name = "log_linear_depolarization_ratio_h",
    units = "dB",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = LDRV,
    name = "LDRV_F",
    long_name = "linear_depolarization_ratio_v_channel",
    standard_name = "log_linear_depolarization_ratio_v",
    units = "dB",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = RHOHV,
    name = "RHOHV_F",
    long_name = "cross_correlation_ratio",
    standard_name = "cross_correlation_ratio_hv",
    units = "",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.001,
    offset = 0
  }
  ,
  {
    id = PHIDP,
    name = "PHIDP_F",
    long_name = "differential_phase",
    standard_name = "differential_phase_hv",
    units = "deg",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = KDP,
    name = "KDP_F",
    long_name = "specific_differential_phase",
    standard_name = "specific_differential_phase_hv",
    units = "deg/km",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.001,
    offset = 0
  }
  ,
  {
    id = PSOB,
    name = "PSOB_F",
    long_name = "phase_shift_on_backscatter",
    standard_name = "phase_shift_on_backscatter",
    units = "deg",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.001,
    offset = 0
  }
  ,
  {
    id = SNRHC,
    name = "SNRHC_F",
    long_name = "signal_to_noise_ratio_db_h_copol_channel",
    standard_name = "signal_to_noise_ratio_hc",
    units = "dB",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = SNRHX,
    name = "SNRHX_F",
    long_name = "signal_to_noise_ratio_db_h_crosspol_channel",
    standard_name = "signal_to_noise_ratio_hx",
    units = "dB",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = SNRVC,
    name = "SNRVC_F",
    long_name = "signal_to_noise_ratio_db_v_copol_channel",
    standard_name = "signal_to_noise_ratio_vc",
    units = "dB",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = SNRVX,
    name = "SNRVX_F",
    long_name = "signal_to_noise_ratio_db_v_crosspol_channel",
    standard_name = "signal_to_noise_ratio_vx",
    units = "dB",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = DBMHC,
    name = "DBMHC_F",
    long_name = "power_in_dbm_h_copol_channel",
    standard_name = "log_power_hc",
    units = "dBm",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = DBMHX,
    name = "DBMHX_F",
    long_name = "power_in_dbm_h_crosspol_channel",
    standard_name = "log_power_hx",
    units = "dBm",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = DBMVC,
    name = "DBMVC_F",
    long_name = "power_in_dbm_v_copol_channel",
    standard_name = "log_power_vc",
    units = "dBm",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = DBMVX,
    name = "DBMVX_F",
    long_name = "power_in_dbm_v_crosspol_channel",
    standard_name = "log_power_vx",
    units = "dBm",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = NCP,
    name = "NCP_F",
    long_name = "normalized_coherent_power",
    standard_name = "normalized_coherent_power",
    units = "",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.001,
    offset = 0
  }
  ,
  {
    id = NOISE_FLAG,
    name = "NOISE_FLAG",
    long_name = "flag_to_indicate_presence_of_noise_only",
    standard_name = "flag_to_indicate_presence_of_noise_only",
    units = "",
    encoding = OUTPUT_ENCODING_INT08,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = SIGNAL_FLAG,
    name = "SIGNAL_FLAG",
    long_name = "flag_to_indicate_presence_of_signal_only",
    standard_name = "flag_to_indicate_presence_of_signal_only",
    units = "",
    encoding = OUTPUT_ENCODING_INT08,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = NOISE_BIAS_DB_HC,
    name = "NOISE_BIAS_DB_HC",
    long_name = "estimated_noise_bias_hc",
    standard_name = "estimated_noise_bias_hc",
    units = "dB",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = NOISE_BIAS_DB_VC,
    name = "NOISE_BIAS_DB_VC",
    long_name = "estimated_noise_bias_vc",
    standard_name = "estimated_noise_bias_vc",
    units = "dB",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_DYNAMIC,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = PARTICLE_ID,
    name = "PID",
    long_name = "particle_id",
    standard_name = "hydrometeor_type",
    units = "",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_SPECIFIED,
    scale = 1,
    offset = 0
  }
  ,
  {
    id = TEMP_FOR_PID,
    name = "TEMP_FOR_PID",
    long_name = "temperature_for_computing_pid",
    standard_name = "temperature",
    units = "C",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_SPECIFIED,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = PRECIP_RATE_ZH,
    name = "RATE_ZH",
    long_name = "precip_rate_from_z",
    standard_name = "precip_rate_from_z",
    units = "mm/hr",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_SPECIFIED,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = PRECIP_RATE_Z_ZDR,
    name = "RATE_Z_ZDR",
    long_name = "precip_rate_from_z_and_zdr",
    standard_name = "precip_rate_from_z_and_zdr",
    units = "mm/hr",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_SPECIFIED,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = PRECIP_RATE_KDP,
    name = "RATE_KDP",
    long_name = "precip_rate_from_kdp",
    standard_name = "precip_rate_from_kdp",
    units = "mm/hr",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_SPECIFIED,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = PRECIP_RATE_KDP_ZDR,
    name = "RATE_KDP_ZDR",
    long_name = "precip_rate_from_kdp_and_zdr",
    standard_name = "precip_rate_from_kdp_and_zdr",
    units = "mm/hr",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_SPECIFIED,
    scale = 0.01,
    offset = 0
  }
  ,
  {
    id = PRECIP_RATE_HYBRID,
    name = "RATE_HYBRID",
    long_name = "precip_rate_hybrid_of_zh_zzdr_kdp_and_kdpzdr",
    standard_name = "precip_rate_hybrid_of_zh_zzdr_kdp_and_kdpzdr",
    units = "mm/hr",
    encoding = OUTPUT_ENCODING_INT16,
    scaling = OUTPUT_SCALING_SPECIFIED,
    scale = 0.01,
    offset = 0
  }
};

//======================================================================
//
// CENSORING OUTPUT FIELDS.
//
// You have the option of censoring the output data fields - i.e. 
//   setting the fields to missing values - at gates which meet certain 
//   criteria. If this is done correctly, it allows you to preserve the 
//   valid data and discard the noise, thereby improving compression. This 
//   leads to smaller data files.
//
//======================================================================
 
///////////// censoring_mode //////////////////////////
//
// Control of the censoring operation.
// 	CENSORING_NONE: no censoring performed.
// 	CENSORING_BY_NOISE_FLAG: censor fields for gates with NOISE_FLAG set 
//   to true.
// 	CENSORING_BY_SNR_AND_NCP: censoring is performed using thresholds 
//   applied to SNR and NCP.
//
// Type: enum
// Options:
//     CENSORING_NONE
//     CENSORING_BY_NOISE_FLAG
//     CENSORING_BY_SNR_AND_NCP
//

censoring_mode = CENSORING_BY_NOISE_FLAG;

///////////// censoring_snr_threshold /////////////////
//
// SNR threshold for censoring (dB).
// Applies to CENSORING_BY_SNR_AND_NCP mode. Censoring is applied if 
//   both SNR and NCP are below the specified thresholds.
// Type: double
//

censoring_snr_threshold = 2;

///////////// censoring_ncp_threshold /////////////////
//
// NCP threshold for censoring.
// Applies to CENSORING_BY_SNR_AND_NCP mode. Censoring is applied if 
//   both SNR and NCP are below the specified thresholds.
// Type: double
//

censoring_ncp_threshold = 0.2;

//======================================================================
//
// OUTPUT FILE FORMAT.
//
//======================================================================
 
///////////// output_format ///////////////////////////
//
// Format for the output files.
//
// Type: enum
// Options:
//     OUTPUT_FORMAT_CFRADIAL
//     OUTPUT_FORMAT_DORADE
//     OUTPUT_FORMAT_FORAY
//     OUTPUT_FORMAT_NEXRAD
//     OUTPUT_FORMAT_UF
//

output_format = OUTPUT_FORMAT_CFRADIAL;

///////////// netcdf_style ////////////////////////////
//
// NetCDF style - if output_format is CFRADIAL.
// netCDF classic format, netCDF 64-bit offset format, netCDF4 using 
//   HDF5 format, netCDF4 using HDF5 format but only netCDF3 calls.
//
// Type: enum
// Options:
//     CLASSIC
//     NC64BIT
//     NETCDF4
//     NETCDF4_CLASSIC
//

netcdf_style = NETCDF4;

//======================================================================
//
// OUTPUT BYTE-SWAPPING and COMPRESSION.
//
//======================================================================
 
///////////// output_native_byte_order ////////////////
//
// Option to leave data in native byte order.
// If false, data will be byte-swapped as appropriate on output.
// Type: boolean
//

output_native_byte_order = FALSE;

///////////// output_compressed ///////////////////////
//
// Option to compress data fields on output.
// Applies to netCDF and Dorade. UF does not support compression.
// Type: boolean
//

output_compressed = TRUE;

///////////// compression_level ///////////////////////
//
// Compression level for output, if compressed.
// Applies to netCDF only. Dorade compression is run-length encoding, 
//   and has not options..
// Type: int
//

compression_level = 9;

//======================================================================
//
// OUTPUT DIRECTORY AND FILE NAME.
//
//======================================================================
 
///////////// output_dir //////////////////////////////
//
// Output directory path.
// Files will be written to this directory.
// Type: string
//

output_dir = "$(DATA_DIR)/cfradial/qc/sband/sur";

///////////// compute_output_path_using_end_time //////
//
// Compute the output file name using the end time of the volume or 
//   sweep.
// If false, the start time will be used instead.
// Type: boolean
//

compute_output_path_using_end_time = FALSE;

///////////// append_day_dir_to_output_dir ////////////
//
// Add the day directory to the output directory.
// Path will be output_dir/yyyymmdd/filename.
// Type: boolean
//

append_day_dir_to_output_dir = TRUE;

///////////// append_year_dir_to_output_dir ///////////
//
// Add the year directory to the output directory.
// Path will be output_dir/yyyy/yyyymmdd/filename.
// Type: boolean
//

append_year_dir_to_output_dir = FALSE;

///////////// write_individual_sweeps /////////////////
//
// Option to write out individual sweeps if appropriate.
// If true, the volume is split into individual sweeps for writing. 
//   Applies to CfRadial format. This is always true for DORADE format 
//   files.
// Type: boolean
//

write_individual_sweeps = FALSE;

