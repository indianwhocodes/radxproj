/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR (c) 1990 - 2016                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
#ifdef __cplusplus
 extern "C" {
#endif


/************************************************************
 * DsInputPath.h
 *
 * Handling of input paths for data system files into archive and
 * realtime programs.  Data system files are expected to be stored
 * in files whose paths match the following pattern:
 *         <file_path>/YYYYMMDD/hhmmss.<ext>
 *
 * There are three modes of operation, reflected by the different
 * constructors.
 *
 * Archive mode:
 *   The constructor passes in a list of data file paths.
 *   This list is stored, and then the paths are served out
 *   when next() is called. If next() returns NULL, the list
 *   is exhausted.
 *
 * Realtime mode:
 *   The constructor passes in an input directory to watch, as well as
 *   as max valid age and a heartbeat function to be called while
 *   waiting for new data to arrive. When next() is called, the
 *   routine will watch the input directory for a new file. When
 *   a new file arrives the path is returned by next(). If the
 *   heartbeat_func is not NULL, it gets called every second while
 *   next() is waiting for a file to arrive.
 *
 *   Note that realtime mode is also used for applications that
 *   want to retrieve filenames for archive data using requested
 *   data times.
 *
 * Triggered mode:
 *   The constructor passes in an input directory to use.  In this
 *   mode, it is expected that the calling program is triggering off
 *   of another data source and then just wants the closest data
 *   from this data source to be used with the triggering data.
 *   This can be used in both archive and realtime modes.  In realtime
 *   mode, the blocking routine can be used to wait for new data to
 *   arrive within the specified interval.
 *
 * Mike Dixon, RAP, NCAR, P.O.Box 3000, Boulder, CO, 80307-3000, USA
 *
 * March 1998
 *
 ************************************************************/

#ifndef ds_input_path_H
#define ds_input_path_H

#include <toolsa/umisc.h>
#include <toolsa/ldata_info.h>
#include <toolsa/membuf.h>

/*
 * typedef for heartbeat function. If heartbeat_func is non-null,
 * the client must provide a pointer to a function which fits this
 * prototype. The label will be generated by this class prior
 * to calling the heartbeat function.
 */

typedef void (*DsInput_heartbeat_t)(const char *label);


typedef enum
{
  DSINP_REALTIME_MODE,
  DSINP_ARCHIVE_MODE,
  DSINP_TRIGGERED_MODE
} DSINP_mode_t;

typedef struct
{
  char *input_dir;
  char *prog_name;
  char **file_paths;
  char input_path[MAX_PATH_LEN];
    
  DSINP_mode_t mode;
  int n_files;
  int file_num;
  int max_age;
  int debug;

  int use_ldata_info;
  int latest_file_only;
  time_t latest_time_used;

  MEMbuf *mbuf_paths;

  LDATA_handle_t last_data;

  DsInput_heartbeat_t heartbeat_func;
  
} DSINP_handle_t;


/*
 * Dataset time information.
 */

typedef struct
{
  time_t gen_time;         /* Dataset generation time. */
  time_t forecast_time;    /* Dataset forecast time.  Set to -1 for datasets */
                           /*   that don't contain forecasts. */
} DSINP_dataset_time_t;


/*****************************************************
 * Function prototypes.
 */


/*****************************
 * Constructor - Archive mode
 *
 * Pass in a list of file paths.
 */

void DSINP_create_archive_list(DSINP_handle_t *handle,
			       char *prog_name,
			       int debug,
			       int n_files,
			       char **file_paths);

/*****************************
 * Constructor - Archive mode
 *
 * Pass in data directory and start and end times.
 */

void DSINP_create_archive_time(DSINP_handle_t *handle,
			       char *prog_name,
			       int debug,
			       char *input_dir,
			       time_t start_time,
			       time_t end_time);

/*****************************
 * Constructor - realtime mode
 *
 * Pass in (a) the input directory to be watched.
 *         (b) the max valid age for a realtime file (secs)
 *             the routine will wait for a file with the age
 *             less than this.
 *         (c) pointer to heartbeat_func. If NULL this is ignored.
 *             If non-NULL, this is called once per second while
 *             the routine is waiting for new data.
 */

void DSINP_create_realtime(DSINP_handle_t *handle,
			   char *prog_name,
			   int debug,
			   char *input_dir,
			   int max_valid_age,
			   DsInput_heartbeat_t heartbeat_func);

/*****************************************************************
 * Constructor - realtime mode version 2 - with non_ldata option.
 *
 * Pass in (a) the input directory to be watched.
 *         (b) the max valid age for a realtime file (secs)
 *             the routine will wait for a file with the age
 *             less than this.
 *         (c) pointer to heartbeat_func. If NULL this is ignored.
 *             If non-NULL, this is called once per second while
 *             the routine is waiting for new data.
 *         (d) use_ldata_info flag. If true, we use the latest_data_info
 *             file, if false we watch the directory recursively
 *             for new files.
 *         (e) latest_file_only flag. Only applies if use_ldata_info is
 *             false. If set, the routine returns the latest file.
 *             If false, it returns the earliest file which is younger than
 *             the max valid age and which has not been used yet.
 */

void DSINP_create_realtime_2(DSINP_handle_t *handle,
			     char *prog_name,
			     int debug,
			     char *input_dir,
			     int max_valid_age,
			     DsInput_heartbeat_t heartbeat_func,
			     int use_ldata_info,
			     int latest_file_only);

/*****************************
 * Constructor - Triggered mode
 *
 * Pass in data directory.
 */

void DSINP_create_triggered(DSINP_handle_t *handle,
			    char *prog_name,
			    int debug,
			    char *input_dir);

/*****************************
 * Destructor
 */

void DSINP_free(DSINP_handle_t *handle);

/*****************************
 * get closest file to given time within the given time margin
 *
 * On success, returns the name of the closest file.  This pointer
 * points to static memory which should not be freed by the caller.
 * On failure, returns NULL.
 *
 * Returns the data time of the file (based on the file name) in
 * the argument list.
 */

char *DSINP_get_closest(DSINP_handle_t *handle,
			time_t search_time,
			int max_time_offset,
			time_t *data_time);

/*****************************
 * get closest file to given time within the given time margin, wait
 * if there is currently no data within the time margin.
 *
 * On success, returns the name of the closest file.  This pointer
 * points to static memory which should not be freed by the caller.
 * On failure, returns NULL.
 *
 * Returns the data time of the file (based on the file name) in
 * the argument list.
 */

char *DSINP_get_closest_blocking(DSINP_handle_t *handle,
				 time_t search_time,
				 int max_time_offset,
				 DsInput_heartbeat_t heartbeat_func,
				 time_t *data_time);

/*****************************
 * get latest data file after the given time, but within the
 * given offset.
 *
 * On success, returns the name of the closest file.  This pointer
 * points to static memory which should not be freed by the caller.
 * On failure, returns NULL.
 *
 * Returns the data time of the file (based on the file name) in
 * the argument list.
 */

char *DSINP_get_first_after(DSINP_handle_t *handle,
			    time_t search_time,
			    int max_time_offset,
			    time_t *data_time);

/*****************************
 * get latest data file before the given time, but within the
 * given offset.
 *
 * On success, returns the name of the closest file.  This pointer
 * points to static memory which should not be freed by the caller.
 * On failure, returns NULL.
 *
 * Returns the data time of the file (based on the file name) in
 * the argument list.
 */

char *DSINP_get_first_before(DSINP_handle_t *handle,
			     time_t search_time,
			     int max_time_offset,
			     time_t *data_time);

/*****************************
 * get next file path
 *
 * Realtime and Archive modes only
 *
 * returns NULL on failure
 */

char *DSINP_next(DSINP_handle_t *handle);

/*****************************
 * get latest file written to the input directory
 *
 * Realtime mode only
 *
 * returns NULL on failure
 */

char *DSINP_latest(DSINP_handle_t *handle);

/*****************************
 * get new file written to the input directory since
 * given last data time.
 *
 * Realtime mode only
 *
 * returns NULL on failure
 */

char *DSINP_new_data(DSINP_handle_t *handle,
		     time_t last_data_time);

/*****************************
 * reset to start of list
 * 
 * Archive mode only.
 */

void DSINP_reset(DSINP_handle_t *handle);

/*****************************
 * get the data time information from the given file path.  The
 * file path is assumed to be in the format described above.
 * The path MUST include the subdirectory with the date information.
 *
 * Returns -1 if an error is encountered.
 */

time_t DSINP_get_data_time(DSINP_handle_t *handle,
			   char *file_path);

/*****************************
 * Get the latest data time for the data.  Note that this is the last
 * data created which is not necessarily the ending data time.
 *
 * Returns -1 if an error is encountered.
 */

time_t DSINP_get_last_time(DSINP_handle_t *handle);

/*****************************
 * Get the begin and end times for the data.
 *
 * Returns 0 on success, -1 if an error is encountered.
 */

int DSINP_get_begin_and_end_times(DSINP_handle_t *handle,
				  time_t *begin_time, time_t *end_time);


/********************************************************************
 * GENERAL UTILITIES (don't require a handle structure)
 ********************************************************************/

/*****************************
 * DSINP_get_dataset_times
 *
 * Retrieves the available data times for datasets generated between
 * the given times.  If begin_gen_time is -1, retrieves all dataset
 * times from the beginning of the data.  If end_gen_time is -1,
 * retrieves all dataset times until the latest time.
 *
 * Returns a pointer to an array of available dataset times, or NULL
 * if there are no datasets generated between the times or if there
 * was an error.  Returns a pointer to static memory which should NOT
 * be freed by the calling routine.
 */

DSINP_dataset_time_t *DSINP_get_dataset_times(char *input_dir,
					      time_t begin_gen_time,
					      time_t end_gen_time,
					      int *num_datasets);


time_t get_forecast_time(char *filename, char* g_string, char *date_string);
time_t get_non_forecast_time(char *filename, char *date_string);
int is_non_forecast_filename(char *filename);
int is_forecast_filename(char *filename);
int is_forecast_g_dir(char *filename);
int is_date(char *name);
int match_expression(char *str, char *expr);
int get_ymd(date_time_t* dt, char* str);
int get_hms(date_time_t* dt, char* str, int index);
int get_forecast_seconds(char* str);
int get_next_directory(char* file_path_copy, char** slash_posn, char** str);


#endif

#ifdef __cplusplus
}
#endif
