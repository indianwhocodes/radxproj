/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR (c) 1990 - 2016                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/*
 * NAME
 * 	translate_bdry
 *
 * PURPOSE
 * 	Given an array of boundary points and a translation vector
 * generate a new boundary containing all points generated by shifting
 * the boundary by the translation
 *
 * NOTES
 * 	
 *
 * HISTORY
 *     wiener - Feb 26, 1993: Created.
 */
#include <math.h>
#include <euclid/boundary.h>
#include <euclid/clump.h>

/*
 * DESCRIPTION:    
 * 	translate_bdry - find the boundary enclosing all points
 * generated by translating a boundary by a vector
 *
 * INPUTS:
 * 	in_bdry - array of input boundary points
 * 	in_bdry_size - dimension of in_bdry
 * 	vect - translation vector
 * 	bbox - box bounding the boundary
 *
 * OUTPUTS:
 * 	out_bdry - array of output boundary points
 * 	out_bdry_size - dimension of out_bdry (should be in_bdry_size + 2)
 *
 * RETURNS:
 *       0 on success, -1 on failure
 *
 * NOTES:
 *  	The bounding box is given in integer coordinates and the
 * boundary is given in floating point coordinates.  This routine assumes
 * that the boundary consists of line segments parallel to the x and y
 * coordinate axes.  If the boundary is a simple closed polygon, 
 * translate_poly_bdry below.
 */
int EG_translate_bdry(Point_d *in_bdry, int in_bdry_size, Point_d vect, Box_2d bbox, Point_d *out_bdry, int out_bdry_size)
{
  int after;
  int before;
  int ct;
  double dir;
  double dir1;
  double dir2;
  Point_d end;
  int first;
  int i;
  int min;
  int max;
  int second;
  Point_d vorigin;		/* origin for vector */

  if (out_bdry_size < in_bdry_size + 2)
    return(-1);

/*
 * the boundary wraps back to its initial point so subtract 1 to get the
 * number of distinct points in the boundary
 */
  in_bdry_size--;

  /*
   * If vect is attached to the various corners of the bounding box, the
   * line corresponding to vect will either intersect the interior of the
   * box or it will not.  Select the lower corner of the bounding box
   * where the line corresponding to vect does not intersect the interior
   * by determining the quadrant for vect.
   */
  if (sgn(vect.x) == sgn(vect.y))
    {
      vorigin.x = bbox.xmax;
      vorigin.y = bbox.ymin;
    }
  else
    {
      vorigin.x = bbox.xmin;
      vorigin.y = bbox.ymin;
    }
      
  /*
   * find the extreme points of in_bdry with respect to the given input
   * vector
   */
  end.x = vorigin.x + vect.x;
  end.y = vorigin.y + vect.y;
  EG_find_extreme_pts(in_bdry, in_bdry_size, &vorigin, &end, &max, &min);
  printf("extreme pts are max %d, min %d\n", max, min);

  /*
   * determine the order of the min and max points in in_bdry
   */
  if (min < max)
    {
      first = min;
      second = max;
    }
  else
    {
      first = max;
      second = min;
    }
  
  before = (in_bdry_size + (first - 1)) % in_bdry_size;
  after = (in_bdry_size + (first + 1)) % in_bdry_size;

  dir = (in_bdry[first].x) * (vect.x) + (in_bdry[first].y) * vect.y;

  dir1 = (in_bdry[before].x) * (vect.x) + (in_bdry[before].y) * vect.y;

  dir2 = (in_bdry[after].x) * (vect.x) + (in_bdry[after].y) * vect.y;

/*  printf("in_bdry_size %d, before %d, first %d, after %d\n", in_bdry_size, before, first, after);
  printf("vect %f, %f\n", vect.x, vect.y);
  printf("before %f, %f, first %f, %f, after %f, %f\n", in_bdry[before].x, in_bdry[before].y, in_bdry[first].x, in_bdry[first].y, in_bdry[after].x, in_bdry[after].y);
  printf("1st dir is %f\n", dir);
  printf("2nd dir is %f\n", dir1 - dir);
  printf("3rd dir is %f\n", dir2 - dir);
*/
  ct = 0;

  if (dir1 - dir < 0  || dir2 - dir > 0 )
    {
      /* store part of in_bdry that is not translated */
      for (i=second; i<in_bdry_size; i++)
	{
	  out_bdry[ct++] = in_bdry[i];
	}
      for (i=0; i<=first; i++)
	{
	  out_bdry[ct++] = in_bdry[i];
	}

      /* translate remaining boundary points */
      for (i=first; i<=second; i++)
	{
	  out_bdry[ct].x = in_bdry[i].x + vect.x;
	  out_bdry[ct].y = in_bdry[i].y + vect.y;
	  ct++;
	}
    }
  else 
    {
      /* store part of in_bdry that is not translated */
      for (i=first; i<=second; i++)
	{
	  out_bdry[ct++] = in_bdry[i];
	}

      /* translate remaining boundary points */
      for (i=second; i<in_bdry_size; i++)
	{
	  out_bdry[ct].x = in_bdry[i].x + vect.x;
	  out_bdry[ct].y = in_bdry[i].y + vect.y;
	  ct++;
	}
      for (i=0; i<=first; i++)
	{
	  out_bdry[ct].x = in_bdry[i].x + vect.x;
	  out_bdry[ct].y = in_bdry[i].y + vect.y;
	  ct++;
	}
    }

  out_bdry[ct].x = out_bdry[0].x;
  out_bdry[ct].y = out_bdry[0].y;
  ct++; 
  return(ct);
}


