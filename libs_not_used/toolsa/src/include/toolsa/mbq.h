/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR (c) 1990 - 2016                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */

/************************************************************************

Header: mbq.h

Author: Mike Dixon

Date:	March 1997

Description: Include file for the MBQ module.

The MBQ module is a wrapper around MB.

It allows the user to write and then read them without the reader
having prior knowldge about their size. This is accomplished by
sending 2 BM messages for every user message. The first is a header,
MBQ_header_t, which stores the message size. The second message is the
user message itself. On the reading side the header, which is of known
length, is read first. Since this holds the size of the following
message the reader can allocate the required memory for the body of
the message, which is aquired in a second read.

The header has two fields which the user can load up to indentify the
type of message. These are the 'type' and 'subtype' fields. They are
not used by the MBQ module itself, but are passed through for use by the
reading program.

The error messages generated by MB are negative integers. Where appropriate
these errors are passed up to the user. Refer to mb.doc for details on
decoding these errors.

*************************************************************************/

#ifndef MBQ_H
#define MBQ_H

#ifdef __cplusplus
 extern "C" {
#endif

#include <dataport/port_types.h>
#include <toolsa/mb.h>

#define MBQ_MAGIC 0xf0f1f2f3

/* 
 * MBQ header type - each MBQ message is made up of one header
 * message and one body message
 */
   
typedef struct {

  si32 magic_cookie; /* f0f1f2f3 */
  si32 len;         /* message size in bytes
	             * not this including header */
  si32 type;        /* message type - user-defined */
  si32 subtype;     /* message subtype - user-defined */

} MBQ_header_t;

/*
 * MBQ handle struct
 */

typedef struct {

  char *prog_name;    /* calling program name */
  char *mbq_path;     /* message queue path */
  void *msg;          /* message */

  int debug;          /* debug flag */
  int latest_id_read; /* latest id read by MBQ_read() */
  int mbid;           /* message buffer id */
  int n_msg_alloc;    /* number of bytes allocated for msg */
  int mb_size;        /* mb size */
  int maxn_msgs;      /* max number of messages */

  si32 magic_cookie;  /* f0f1f2f3 */

  MBQ_header_t hdr;   /* header */

} MBQ_handle_t;

/*
 * prototypes
 */

/*******************
 * MBQ_init_handle()
 *
 * Initialize MBQ handle
 *
 * This must be done before using the handle for any
 * other function.
 */

extern void MBQ_init_handle(MBQ_handle_t *handle,
			    char *prog_name,
			    int debug);

/***************
 *  MBQ_create()
 *
 *  This function creates a new RDWR message buffer with the given
 *  max buffer size and and maximum number of messages.
 *
 *  Parameters:
 *    handle - MBQ handle
 *    mbq_path - name of the message buffer which should already be created.
 *    max_buf_size - the maximum size of the buffer
 *    max_n_msgs - the maximum number of MB messages.
 *
 *  Return value:
 *    0 on success,
 *    On error, negative status returned from the _MB_open() call.
 *              Refer to mb.doc.
 */

extern int MBQ_create (MBQ_handle_t *handle,
		       char *mbq_path,
		       int max_buf_size,
		       int max_n_msgs);

/********************
 *  MBQ_open()
 *
 *  This function opens an MB RDONLY.
 *
 *  Parameters:
 *    handle - MBQ handle
 *    mbq_path - name of the message buffer which should already be created.
 *
 *  Return value:
 *    0 on success,
 *    On error, negative status returned from the _MB_open() call.
 *              Refer to mb.doc.
 */

extern int MBQ_open (MBQ_handle_t *handle, char *mbq_path);

/********************
 *  MBQ_write()
 *
 *  This function writes a message to an MBQ. 
 *
 * This actually writes two messages:
 *
 *   1. MBQ_header_t struct filled out appropriately
 *   2. message itself
 *
 *  Parameters:
 *    handle - MBQ handle
 *    message - message array
 *    mess_len - message length in bytes
 *    mess_type - user-defined and used message type
 *    mess_subtype - user-defined and used message subtype
 *
 *  Note: the type and subtype are not used by the MBQ module but
 *        are passed through so the reading routine can determine
 *        something about the message from the header.
 *
 *  Return value:
 *    0 on success,
 *    On error, negative status returned from the _MB_write() call.
 *              Refer to mb.doc.
 *
 */

extern int MBQ_write (MBQ_handle_t *handle, void *message, int mess_len,
		      int mess_type, int mess_subtype);

/************************
 *  MBQ_message_waiting()
 *
 *  Check if a message is waiting in the queue.
 *
 *  Returns:
 *    1 if YES
 *    0 if NO
 *    On error, negative status returned from _MB_stat() call
 *              Refer to mb.doc.
 */

extern int MBQ_message_waiting (MBQ_handle_t *handle);

/********************
 *  MBQ_read()
 *
 * This function reads a message from an MBQ
 *
 * This actually reads two messages:
 *
 *   1. MBQ_header_t struct which gives data on the message.
 *   2. message itself
 *
 *  Parameters:
 *    handle - MBQ handle
 *
 *  Return value:
 *    nbytes_read on success;
 *    0 if no message is available;
 *    On error, negative status returned from the _MB_read() call.
 *              Refer to mb.doc.
 */

extern int MBQ_read (MBQ_handle_t *handle);

/********************
 *  MBQ_read_block()
 *
 * This function reads a message from an MBQ - it blocks until
 * a message is received.
 *
 * This actually reads two messages:
 *
 *   1. MBQ_header_t struct which gives data on the message.
 *   2. message itself
 *
 *  Parameters:
 *    handle - MBQ handle
 *    msecs_sleep - number of millisecs to sleep between reads
 *                  while waiting for a message to arrive.
 *
 *  Return value:
 *    nbytes_read on success;
 *    On error, negative status returned from the _MB_read() call.
 *              Refer to mb.doc.
 */

extern int MBQ_read_block (MBQ_handle_t *handle,
			   int msecs_sleep);

/********************
 *  MBQ_seek_end()
 *
 *  Seek to the end of the MBQ
 *
 *  Return value:
 *    0 on success;
 *    On error, negative status returned from the _MB_seek() call.
 *              Refer to mb.doc.
 */

extern int MBQ_seek_end (MBQ_handle_t *handle);

/********************
 *  MBQ_close()
 *
 *  Close the MBQ
 *
 */

extern void MBQ_close (MBQ_handle_t *handle);

/********************
 *  MBQ_free()
 *
 *  Free memory assocaited with the MBQ
 *
 */

extern void MBQ_free (MBQ_handle_t *handle);

#ifdef __cplusplus
}
#endif

#endif





