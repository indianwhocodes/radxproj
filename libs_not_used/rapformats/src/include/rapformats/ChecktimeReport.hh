// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
// ** Copyright UCAR (c) 1990 - 2016                                         
// ** University Corporation for Atmospheric Research (UCAR)                 
// ** National Center for Atmospheric Research (NCAR)                        
// ** Boulder, Colorado, USA                                                 
// ** BSD licence applies - redistribution and use in source and binary      
// ** forms, with or without modification, are permitted provided that       
// ** the following conditions are met:                                      
// ** 1) If the software is modified to produce derivative works,            
// ** such modified software should be clearly marked, so as not             
// ** to confuse it with the version available from UCAR.                    
// ** 2) Redistributions of source code must retain the above copyright      
// ** notice, this list of conditions and the following disclaimer.          
// ** 3) Redistributions in binary form must reproduce the above copyright   
// ** notice, this list of conditions and the following disclaimer in the    
// ** documentation and/or other materials provided with the distribution.   
// ** 4) Neither the name of UCAR nor the names of its contributors,         
// ** if any, may be used to endorse or promote products derived from        
// ** this software without specific prior written permission.               
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
//=============================================================================
//
//  RAP, NCAR, P.O.Box 3000, Boulder, CO, 80307-3000, USA
//
//      File: $$
//      Version: $$  Dated: $$
//
//=============================================================================
//

/**
 * @file ChecktimeReport.hh
 * 
 * Data format for deicing fluid checktimes generated by the CheckTimeDisp program
 * 
 * Data is stored in a buffer of buf_len, in the following order:
 *  
 *   ChecktimeReport::checktime_header_t:   just the one of these
 *   ChecktimeReport::checktime_fluid_t:    num_fluids of these
 *
 * The report is converted to and from a byte array using the assemble() 
 * and disassemble() functions, which handle byte swapping where needed.
 *
 * @date September 2011
 * @author gaydos
 */

#ifndef CHECKTIMES_H
#define CHECKTIMES_H

#include <stdio.h>
#include <dataport/port_types.h>
#include <string>
#include <string.h>
#include <ctime>
#include <dataport/bigend.h>
#include <toolsa/MemBuf.hh>
#include <toolsa/mem.h>
#include <vector>

using namespace std;

#define CHECKTIME_NAN 0

/* @brief Fluid List */
#define CT_GENERIC_TYPE_I                             1
#define CT_CLARIANT_SAFEWING_MP_II_1951             100
#define CT_CLARIANT_SAFEWING_MP_II_2025_ECO         101
#define CT_CLARIANT_SAFEWING_MP_II_FLIGHT           102
#define CT_CLARIANT_SAFEWING_MP_IV_2001             103
#define CT_CLARIANT_SAFEWING_MP_IV_2012_PROTECT     104
#define CT_CLARIANT_SAFEWING_MP_IV_LAUNCH           105
#define CT_KILFROST_ABC_II_PLUS                     200
#define CT_KILFROST_ABC_2000                        201
#define CT_KILFROST_ABC_K_PLUS                      202
#define CT_KILFROST_ABC_S                           203
#define CT_KILFROST_ABC_S_PLUS                      204
#define CT_KILFROST_ABC_4                           205
#define CT_DOW_UCAR_ADF_AAF_ULTRA_PLUS              300
#define CT_DOW_UCAR_ENDURANCE_EG106                 301
#define CT_DOW_UCAR_FLIGHTGUARD_AD480               302
#define CT_OCTAGON_MAX_FLIGHT_04                    400
#define CT_OCTAGON_E_MAX_II                         401

// Status flags for checktime calcluations
#define CT_CHECKTIME_VALID                          0
#define CT_UNKNOWN_PRECIP                           1
#define CT_MISSING_DATA                             2
#define CT_NO_FROZEN_PRECIP                         3
#define CT_OTHER                                    4

class ChecktimeReport
{

public:

  //////////////////
  // Public types //
  //////////////////

  typedef struct
  {
    fl32 gauge_lat;
    fl32 gauge_lon;
    fl32 gauge_alt;
    ui32 time;         // 'now', or the UNIX timestamp for which the report was created
    ui32 num_fluids;
    ui32 buf_len;      // total buffer length, including header
    ui32 spare[3];

  } checktime_hdr_t;

  typedef struct
  {
    ui32 fluid_id;               // ID representing fluid type (see above list)
    ui08 fluid_dilution;         // 0-100%
    ui32 fract_failure_time[9];  // 10% to 90% fluid failure times (UNIX timestamp)
    ui32 checktime;              // 100% failure, or 'checktime' (UNIX timestamp)
    ui08 status;                 // status of Checktime calculation (see above list)
  } checktime_fluid_t;


  /**
   * @brief Default constructor
   */ 
  ChecktimeReport();
  
  /**
   * @brief Alternate constructor
   *
   * @param[in] lat The latitude of the precip gauges
   * @param[in] lon The longitute of the precip gauges
   * @param[in] alt The altitude of the precip gauges
   * @param[in] time The time report is valid, or 'now' (UNIX timestamp) 
   */ 
  ChecktimeReport(fl32 lat, fl32 lon, fl32 alt, ui32 time);

  /**
   * @brief destructor
   */
  virtual ~ChecktimeReport();

  /** @brief setters */
  void setLat(const fl32 lat) { _lat = lat; }
  void setLon(const fl32 lon) { _lon = lon; }
  void setAlt(const fl32 alt) { _alt = alt; }
  void setTime(const ui32 time) { _time = time; }

  /** @brief getters */
  fl32 getLat() { return _lat; }
  fl32 getLon() { return _lon; }
  fl32 getAlt() { return _alt; }
  ui32 getTime() { return _time; }

  /**
   * @brief Remove all fluid checktimes from the fluid list
   */
  void clearFluids();

  /**
   * @brief Add a fluid's checktime to the fluid list
   *
   * @param[in] fluid The fluid to add, with checktime and fract times filled in
   */
  void addFluid(const checktime_fluid_t &fluid);
  
  /**
   * @brief Get the number of fluid checktimes in this report
   */
  int getNFluids() { return _fluids.size(); }

  /**
   * @brief Get all of the fluid checktimes in this report
   *
   * @return A vector containing all of the fluid checktimes
   */
  vector<checktime_fluid_t> getFluids() { return _fluids; }

  /**
   * @brief Get checktimes for a specific fluid and dilution from
   *        this report. If the checktimes for the fluid/dilution
   *        combo are not found, a null pointer is returned
   *
   * @param[in] fluid_id The ID of the desired fluid (see above list)
   * @param[in] fluid_dilution The dilution percentage (0-100)
   *
   * @return The matching fluid checktimes, or NULL
   */
  checktime_fluid_t *getFluid(int fluid_id, int dilution);

  /**
   * @brief Get a pointer to the memory buffer containing this report.
   *        Note: assemble() must be called if any changes were made!
   *
   * @return A pointer to the memory buffer containing this report
   */
  void *getBufPtr() const { return _memBuf.getPtr(); }
  
  /**
   * @brief Get the length (in bytes) of the memory buffer containing this
   *        report
   *
   * @return The number of bytes in this report
   */
  int getBufLen() const { return _memBuf.getLen(); }

  /**
   * @brief Assemble the report header and any fluid checktimes added
   *        to the report into a byte array, suitable for inserting into
   *        the SPDB database
   */
  bool assemble();

  /**
   * @brief Disassemble a byte array (such as one retrieved from a database)
   *        into a ChecktimeReport
   *
   * @param[in] buf A pointer to the byte array containing the checktime report
   * @param[in] len The number of bytes in the byte array
   */
  bool disassemble(const void *buf, int len);
  
  /**
   * @brief Print an ASCII representation of this report to the given file pointer
   *
   * @param[out] fptr A pointer to the file to print to.
   */
  void print(FILE *fptr);

  /**
   * @brief Print an ASCII representation of this report to the given stream
   *
   * @param[out] out The stream to print to
   */
  void print(ostream &out) const;

  /***********************************************************************
   * @brief Convert a string to the associated fluid integer value
   *
   * @param[in] fluid_name A string containing the name of the fluid
   *
   * @return An integer value representing the fluid. This is the value
   *         stored as data_type in the Spdb data chunk. If the string
   *         can't be converted, a -1 is returned
   ***********************************************************************/
  static int get_fluid_value( const string fluid_name );  

  /***********************************************************************
   * @brief Convert a fluid integer value to a string
   *
   * @param[in] fluid_value An integer representing a fluid
   *
   * @return A string containing the name of the fluid. If the value
   *         can't be converted, an empty string is returned
   ***********************************************************************/
  static string get_fluid_name( int fluid_value );  

protected:
  
  /* @brief The latitude of the precip gauges */
  fl32 _lat;

  /* @brief The longitude of the precip gauges */
  fl32 _lon;

  /* @brief The altitude of the precip gauges */
  fl32 _alt;

  /* @brief The time for which the report is valid, or 'now' (UNIX timestamp) */
  ui32 _time;

  /* The vector of fluid checktimes and fractional failure times */
  vector<checktime_fluid_t> _fluids;

  /* @brief The memory buffer containing this report */
  MemBuf _memBuf;

};

#endif



