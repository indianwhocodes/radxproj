/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR (c) 1990 - 2016                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
#ifdef __cplusplus
 extern "C" {
#endif
/**************************************************************************
 * coord_export.h - struct definition for shared memory communication
 *                  between displays and auxiliary processes
 *
 * Frank Hage & Mike Dixon
 *
 * RAP NCAR Boulder CO USA
 * Oct 1993
 *
 **************************************************************************/

#ifndef coord_export_h
#define coord_export_h

#include <time.h>
#include <dataport/port_types.h>

#define CIDD_USER_CLICK 0   /*  The User generated this click */
#define CIDD_RESET_CLICK 1  /* The automatic reset fuction generated the click */
#define CIDD_ZOOM_CLICK 2   /* The user initiated a zoom - click at center point of the zoom */ 

#define CLIENT_USER_CLICK 3  /* The User generated this click via the client */
#define CIDD_OTHER_CLICK -1 /* Click generated by other action */

enum runtime_mode_t {
   RUNMODE_REALTIME = 0,
   RUNMODE_ARCHIVE
};

   enum client_message_t {
     NO_MESSAGE = 0,  /*  Client params/args: char client_args[MAX_CLIENT_EVENT_ARG] */
     NEW_MDV_AVAIL,   /*  New Mdv data Matching Button/ Menu Label is available */
     NEW_SPDB_AVAIL,  /*  New Spdb Data matching menu label */
     RELOAD_DATA,     /*  Force a reload of all data */
     SET_TIME,        /* Set the Display's interest Time */
     SET_NUM_FRAMES,  /* Set the Number of Frames in the MOvie loop */
     SET_FRAME_NUM,   /* Select Which Frame in the movie loop is visible */
     SET_REALTIME     /* Set the Display into Real-Time mode. */
   };

#define MAX_CLIENT_EVENT_ARG 64

typedef struct {

  si32 shmem_ready;            /* set by main display - 
				* starts at 0, set to 1 by main
				* display when it has loaded relevant data */

  ti32 selection_sec;          /* system time at which last selection */
  si32 selection_usec;         /* occurred */

  ti32 time_cent;              /* centroid time of data */
  ti32 time_min;               /* temporal domain of data */
  ti32 time_max;               /* ditto */
  
  si32 pointer_seq_num;        /* set by main display -
				* increments by 1 each time the mouse
				* is clicked in the main display
				* xy plot region */

  si32 button;                 /* set by main display - * pointer button last pressed */

  ti32 epoch_start;           /* time_t GMT of start of epoch(Time domain we are interested in )*/

  ti32 epoch_end;             /* time_t GMT of end of epoch */

  enum client_message_t client_event;          /* Client sets events code here. - Display sets to 0/NO_MESSAGE after reading */

  char client_args[MAX_CLIENT_EVENT_ARG];     /* Arguments, parameters for client events.  */

  si32 display_busy;         /* Display sets to 1 when busy */

  si32 click_type;           /* CIDD_USER_CLICK, CIDD_RESET_CLICK or CIDD_ZOOM_CLICK */

  si32 time_seq_num;         /* Set by the main  display - Incremented every time CIDD updates its interest times. */

  si32 runtime_mode;  /* Set by the Display to REALTIME_MODE or ARCHIVE_MODE */

  /*
   * the following parameters are intended for clients which read
   * either MDV or SPDB data based on information from this
   * shared memory segment
   */

  int checkWriteTimeOnRead;   /* flag to indicate that we should check the
                               * data write time on read. Only data which
                               * existed on the disk at or before
                               * latestValidWriteTime should be read */
  
  ti32 latestValidWriteTime;

  ti32 time_current_field;  /* time of current field in the data */

  ti32 client_click_time;
  si32 client_seq_num; /* sequence number for client clicks */
  si32 client_click_type; /* CLIENT_USER_CLICK */

  si32 click_is_for_vsection;  /* if 1, click is in vertical section window
                                * if 0, click is in horizontal section window */

  ti32 time_data_start;      /* time of start of currently-displayed data */
  ti32 time_data_end;        /* time of end of currently-displayed data */

  si32 ispare[84];

  fl64 pointer_x;            /* set by main display -
				* where pointer was last clicked in
				* main display (km) */

  fl64 pointer_y;            /* set by main display -
				* where pointer was last clicked in
				* main display (km) */

  fl64 pointer_lat;          /* set by main display -
				* where pointer was last clicked in
				* main display (deg) */


  fl64 pointer_lon;           /* set by main display -
				* where pointer was last clicked in
				* main display (deg) */

  /*
   * the focus is intended to be a location of nearest object
   * to (pointer_x, pointer_y)
   */
  
  fl64 focus_x;              /* current x focus (km), determined from
				* pointer_x */

  fl64 focus_y;              /* current y focus (km), determined from
				* pointer_y */

  fl64 focus_lat;            /* current x focus (deg), determined from
				* pointer_x */

  fl64 focus_lon;            /* current y focus (deg), determined from
				* pointer_y */

  fl64 datum_longitude;      /* set by main_display -
				* for main display (x,y) grid */

  fl64 datum_latitude;       /* set by main_display -
				* for main display (x,y) grid */

  fl64 pointer_alt_min;       /* set by main display -
				 * altitude in Km of the base
				 * of the viewing area */

  fl64 pointer_alt_max;       /* set by main display -
				 * altitude in Km of the top
				 * of the viewing area */
  
  fl64 data_altitude;         /* set by main display -
				 * altitude in Km of the 
				 * data plane visible in the window */

  fl64 data_offset_x_km;      /* Set by registration utilities -
				 * distance in Km the 
				 * data should be moved to correct registration */

  fl64 data_offset_y_km;      /* Set by registration utilities
				 * distance in Km the 
				 * data should be moved to correct registration */

  fl64 client_x;            /* set by client -
                               * where user last clicked (km) */
  
  fl64 client_y;            /* set by client -
                               * where user last clicked (km) */

  fl64 client_lat;          /* set by client -
                               * where user last clicked (deg) */

  fl64 client_lon;          /* set by client -
                               * where user last clicked (deg) */

  fl64 pointer_ht_km;       /* height MSL of pointer click (km) */
  fl64 pointer_range_km;    /* distance from origin of pointer click (km) */

  fl64 pointer_az_deg;      /* radar azimuth of pointer click (deg) */
  fl64 pointer_el_deg;      /* radar elevation of pointer click (deg) */

  fl64 dspare[37];

} coord_export_t;
  
#endif
#ifdef __cplusplus
}
#endif
